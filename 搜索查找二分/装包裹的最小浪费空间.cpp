#include<bits/stdc++.h>
using namespace std;


class Solution {
private:
	using LL = long long;

	static constexpr int MOD = 1000000007;

public:
	int minWastedSpace(vector<int>& packages, vector<vector<int>>& boxes) {
		int n = packages.size();
		sort(packages.begin(), packages.end());

		// 计算数组 packages 的前缀和
		vector<LL> pre(n + 1);
		for (int i = 1; i <= n; ++i) {
			pre[i] = pre[i - 1] + packages[i - 1];
		}

		// 辅助函数，通过前缀和数组，得到数组 packages[left..right] 的和
		auto get = [&](int left, int right) {
			return pre[right + 1] - pre[left];
		};

		LL ans = LLONG_MAX;
		for (auto& box : boxes) {
			sort(box.begin(), box.end());
			// 小优化，如果最大包裹的尺寸大于最大箱子的尺寸，那么一定不满足，直接跳过
			if (packages.back() > box.back()) {
				continue;
			}

			// 初始化指针 pt，它指向还未被放入箱子的第一个包裹
			auto pt = packages.begin();
			// 总浪费空间
			LL total = 0;

			for (int y : box) {
				// 小优化，如果当前箱子 y 的尺寸小于 pt 指向的包裹，那么无需进行二分查找
				if (y < *pt) {
					continue;
				}

				// pt'
				auto pt_next = prev(upper_bound(pt, packages.end(), y));

				total += (LL)(pt_next - pt + 1) * y - get(pt - packages.begin(), pt_next - packages.begin());
				pt = next(pt_next);
				// 小优化，如果所有包裹都已经被放入箱子，可以提前退出
				if (pt == packages.end()) {
					break;
				}
			}
			ans = min(ans, total);
		}

		return (ans == LLONG_MAX ? -1 : ans % MOD);
	}
};

