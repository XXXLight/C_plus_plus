#include<bits/stdc++.h>
using namespace std;



class Solution {
public:
	string smallestSubsequence(string s, int k, char letter, int repetition) {
		int  n = s.size();
		int cnt = 0;  // 后面还未扫描到的 letter的数量
		for (int i = 0; i < n; ++i)  //统计letter出现的数量
			if (s[i] == letter) cnt++;
		int toErase = n - k;   // 要删去n - k 个元素
		string res;         // 答案
		int p = 0;          // 目前为止letter已扫描了的次数
		for (int i = 0; i < n; ++i)
		{
			while (toErase && res.size() && s[i] < res.back()) {  // 删去逆序的字母
				if (res.back() == letter) {
					if (repetition > p - 1 + cnt)  // 后面的letter 不够凑成repetition 个letter
						break;
					p--;      // 可以删除
				}
				res.pop_back();
				toErase--;  //删去一个
			}
			if (s[i] == letter) p++, cnt--;  // 前面增加，后面减少
			res += s[i];
		}

		while (res.size() > k) {      // 是因为逆序字母可能不够的原因 会漏删一些 元素，现在检查补上
			if (res.back() == letter) p--;
			res.pop_back();
		}
		for (int i = k - 1; i >= 0; --i) { // 因为前面的元素可能比letter更小，所以要检查一下补上letter
			if (p < repetition  && res[i] != letter) {//(这是为了保证letter个数足够，但letter不够小，所以得从后往前补，保证最小)
				res[i] = letter;
				++p;
			}
		}
		return res;
	}
};

