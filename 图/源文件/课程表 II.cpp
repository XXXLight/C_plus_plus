#include<bits/stdc++.h>
#include<unordered_map>
using namespace std;


// 拓扑排序的DFS解法
// 有向图
class Solution {
private:
	// 存储有向图,邻接表
	vector<vector<int>> edges;
	// 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成
	vector<int> visited;
	// 用数组来模拟栈，下标 0 为栈底，n-1 为栈顶
	vector<int> result;
	// 判断有向图中是否有环，true表示没有环
	bool valid = true;

public:
	void dfs(int u) {
		// 将节点标记为「搜索中」
		visited[u] = 1;
		// 搜索其相邻节点
		// 只要发现有环，立刻停止搜索
		for (int v : edges[u]) {
			// 如果「未搜索」那么搜索相邻节点
			if (visited[v] == 0) {
				dfs(v);
				if (!valid) {
					return;
				}
			}
			// 如果「搜索中」说明找到了环
			else if (visited[v] == 1) {
				valid = false;
				return;
			}
		}
		// 将节点标记为「已完成」
		visited[u] = 2;
		// 将节点入栈
		result.push_back(u);
	}

	vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
		edges.resize(numCourses);
		visited.resize(numCourses);
		for (const auto& info : prerequisites) {
			edges[info[1]].push_back(info[0]); // info[1]是起点，info[0]是终点，想到邻接表就行
		}
		// 每次挑选一个「未搜索」的节点，开始进行深度优先搜索
		for (int i = 0; i < numCourses && valid; ++i) {
			if (!visited[i]) {
				dfs(i);
			}
		}
		if (!valid) {
			return {};
		}
		// 如果没有环，那么就有拓扑排序
		// 注意下标 0 为栈底，因此需要将数组反序输出
		reverse(result.begin(), result.end());
		return result;
	}
};


// 拓扑排序的Kahn解法
class Solution {
private:
	// 存储有向图
	vector<vector<int>> edges;
	// 存储每个节点的入度
	vector<int> indeg;
	// 存储答案
	vector<int> result;

public:
	vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
		edges.resize(numCourses);
		indeg.resize(numCourses);
		for (const auto& info : prerequisites) {
			edges[info[1]].push_back(info[0]); // info[1] =====> info[0]
			++indeg[info[0]]; // info[1] =====> info[0],所以是info[0]入度加1
		}

		queue<int> q;
		// 将所有入度为 0 的节点放入队列中
		for (int i = 0; i < numCourses; ++i) {
			if (indeg[i] == 0) {
				q.push(i);
			}
		}

		while (!q.empty()) {
			// 从队首取出一个节点
			int u = q.front();
			q.pop();
			// 放入答案中
			result.push_back(u);
			for (int v : edges[u]) {
				--indeg[v];
				// 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了
				if (indeg[v] == 0) {
					q.push(v);
				}
			}
		}

		if (result.size() != numCourses) {
			return {};
		}
		return result;
	}
};




// 自己写出来的代码才是好代码
class Solution {
public:
	vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
		unordered_map<int, vector<int>> edges;
		vector<int> indeg(numCourses, 0);
		vector<int> res;
		for (auto& e : prerequisites) {
			edges[e[1]].push_back(e[0]), indeg[e[0]]++;
		}
		queue<int> q;
		for (int i = 0; i < numCourses; i++) {
			if (indeg[i] == 0) q.push(i);
		}
		while (!q.empty()) {
			int cur = q.front();
			q.pop();
			res.push_back(cur);
			for (auto e : edges[cur]) {
				indeg[e]--;
				if (indeg[e] == 0) q.push(e);
			}
		}
		if (res.size() == numCourses) return res;
		else return {};
	}
};
